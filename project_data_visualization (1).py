# -*- coding: utf-8 -*-
"""Project_Data_Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vfrj0wAU69RnVSGxDgEAdOJNg3gaXKrP

**Importing Required Libraries**

**json:**

*This module allows us to work with JSON (JavaScript Object Notation) files.
JSON files are commonly used to store structured data, such as geographic boundaries.*
  
**pandas:**

*A powerful library for data manipulation and analysis.
Here, it is used to load and process the population data.*

**plotly.express:**

*This module simplifies creating interactive visualizations, such as maps and plots.
It will be used to create an interactive choropleth map for visualizing population clusters.*

**sklearn.cluster.KMeans:**

*A machine learning algorithm used for clustering data into groups.
It helps us categorize voivodeships (regions in Poland) based on population into distinct clusters.*

**matplotlib.pyplot**

*A data visualization library. It will be used for plotting various data for this project*

**plotly.io:**

*This module handles rendering visualizations.
The renderers.default setting determines how and where the visualizations will be displayed.*

**Renderer Setting:**

*pio.renderers.default = "colab" ensures that interactive visualizations render directly inside the Colab notebook, making it easier to present and analyze data in this environment.*
"""

import json
import pandas as pd
import plotly.express as px
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

import plotly.io as pio
pio.renderers.default = "colab"

"""**Loading GeoJSON Data**

**Purpose:**
*This line loads geographic boundary data for Poland's voivodeships from a GeoJSON file.*
"""

voivodeships = json.load(open("sample_data/voivodeships.geojson", "r"))

"""**Mapping Voivodeship Names to IDs**

**Purpose:**
*This code creates a mapping between the names of voivodeships and their unique IDs from the GeoJSON data.*

**Code Breakdown:**

Loop through features: Iterates over the "features" in the GeoJSON data.

**Assign unique IDs:**
Adds an "id" field to each feature, using the "vd_code" property as the unique identifier.

**Create state_id_map:**
Maps voivodeship names ("name") to their corresponding "id" values.

**Why is it needed?**
This mapping is essential for linking the names in the population dataset to the GeoJSON regions for visualization.
"""

state_id_map = {}
for feature in voivodeships["features"]:
    feature["id"] = feature["properties"]["vd_code"]
    state_id_map[feature["properties"]["name"]] = feature["id"]

"""**Normalizing Voivodeship Names**

**Purpose:**
*This function standardizes voivodeship names by converting them to lowercase, removing extra spaces, and replacing Polish diacritic characters with their plain equivalents.*

**How It Works:**

**name.strip():** Removes leading and trailing spaces.

**name.lower():** Converts the text to lowercase.

**replace(...):** Replaces special Polish characters (e.g., "ł" becomes "l") to ensure consistent formatting.

**Why is it needed?**

The normalization ensures that voivodeship names in different datasets (e.g., GeoJSON and population data) match despite differences in formatting or character usage.


"""

def normalize_name(name):
    return name.strip().lower().replace("ł", "l").replace("ś", "s").replace("ż", "z").replace("ź", "z").replace("ń", "n").replace("ć", "c").replace("ę", "e").replace("ą", "a").replace("ó", "o")

"""**Normalizing the state_id_map Keys**

**Purpose:**
*This line applies the normalize_name function to all voivodeship names (keys) in the state_id_map dictionary, ensuring consistency in naming.*
"""

state_id_map = {normalize_name(k): v for k, v in state_id_map.items()}

"""**Loading Population Data**

**Purpose:**
*This line loads a CSV file containing population data for Poland's voivodeships into a Pandas DataFrame.*



**Population Data Columns:**

**voivodeship:** *The name of the voivodeship (region).*

**id:** A unique *identifier for each voivodeship.*

**population:** *The population of each voivodeship.*

**number_of_cities:** *The total number of cities in each voivodeship.*
"""

df = pd.read_csv("sample_data/population_data.csv")

"""**Cleaning and Converting the Population Column**

**Purpose:**
*This line ensures that all values in the population column are clean and converted to integers for consistent data processing.*

**How It Works:**

**apply(lambda x: ...):** *Applies a function to each value in the population column.*

**Handle strings with commas:**
*If the value is a string, str(x).replace(",", "") removes commas (e.g., "1,234" becomes "1234").*
*Converts the cleaned string to an integer with int(...).*

**Handle numeric values:**
*If the value is already a number, it is directly cast to an integer.*
"""

df["Population"] = df["population"].apply(
    lambda x: int(str(x).replace(",", "")) if isinstance(x, str) else int(x)
)

"""**Normalizing Voivodeship Names in the DataFrame**

**Purpose:**
*This line applies the normalize_name function to all values in the voivodeship_name column of the DataFrame.*
"""

df["voivodeship_name"] = df["voivodeship_name"].apply(normalize_name)

"""**Mapping Voivodeship Names to IDs**

**Purpose:**
*This line adds a new column, id, to the DataFrame by mapping voivodeship names to their corresponding IDs using the state_id_map dictionary.*
"""

df["id"] = df["voivodeship_name"].map(state_id_map)

"""**Applying K-Means Clustering**

**Purpose:**
*This code uses the K-Means algorithm to group the voivodeships into 5 clusters based on their population size.*

**How It Works:**

**KMeans(n_clusters=5, random_state=0):**
*Initializes the K-Means model with 5 clusters (n_clusters=5) and a fixed random seed (random_state=0) to ensure reproducibility.*

**kmeans.fit_predict(df[["Population"]]):**
*Fits the K-Means model on the Population data and predicts the cluster assignments for each voivodeship.
The result is stored in the Cluster column of the DataFrame.*

**Why is it needed?:**
*Clustering helps categorize voivodeships into groups with similar population sizes, which can then be visualized on a map for better analysis.*
"""

kmeans = KMeans(n_clusters=5, random_state=0)
df["Cluster"] = kmeans.fit_predict(df[["Population"]])

"""**Creating the Choropleth Map**

**Purpose:**
*This code generates an interactive choropleth map using Plotly, visualizing the population clusters of Poland's voivodeships.*

**How It Works:**

**locations="id":**
*Specifies that the geographic locations (voivodeships) are identified by the id column from the DataFrame.*

**geojson=voivodeships:**
*Provides the GeoJSON data that defines the boundaries of the voivodeships.*

**color="Cluster":**
*Colors the regions based on their cluster group (from the Cluster column).*

**hover_name="voivodeship_name":**
*Displays the name of the voivodeship when hovering over a region.*

**hover_data={...}:**
*Customizes the hover data to show the population and number of cities, but hides the id and Cluster values.*

**title="Poland Voivodeships - Population Clusters":**
*Sets the map's title.*

**mapbox_style="carto-positron":**
*Defines the style of the map.*

**center={"lat": 52.0693, "lon": 19.4803}:**
*Centers the map on Poland.*

**zoom=4.5:**
*Sets the zoom level to ensure a good view of Poland.*

**opacity=0.75:**
*Sets the opacity of the regions to 75%, making the map background visible.*
"""

fig = px.choropleth_mapbox(
    df,
    locations="id",
    geojson=voivodeships,
    color="Cluster",  # Group by cluster
    hover_name="voivodeship_name",
    hover_data={
        "id": False,
        "Population": True,
        "number_of_cities": True,
        "Cluster": False,
    },
    title="Poland Voivodeships - Population Clusters",
    mapbox_style="carto-positron",
    center={"lat": 52.0693, "lon": 19.4803},  # Center of Poland
    zoom=4.5,  # Adjust the zoom level
    opacity=0.75,
)

"""**Showing the actual map**"""

fig.show()

"""**Bar Plot of Population by Voivodeship**


"""

# Sort the DataFrame by Population in descending order
df_sorted = df.sort_values(by='Population', ascending=False)

# Create the bar plot
plt.figure(figsize=(12, 6))
plt.bar(df_sorted['voivodeship_name'], df_sorted['Population'], color='skyblue')

plt.title("Population of Each Voivodeship in Poland")
plt.xlabel("Voivodeship")
plt.ylabel("Population")
plt.xticks(rotation=90)  # Rotate x-axis labels for better readability
plt.tight_layout()  # Adjust layout to avoid clipping of labels
plt.show()

"""**Bar Plot of Number of Cities by Voivodeship**"""

# Sort the DataFrame by 'number_of_cities' in descending order
df_sorted_cities = df.sort_values(by='number_of_cities', ascending=False)

# Create the bar plot for the number of cities
plt.figure(figsize=(12, 6))
plt.bar(df_sorted_cities['voivodeship_name'], df_sorted_cities['number_of_cities'], color='green')

plt.title("Number of Cities by Each Voivodeship in Poland")
plt.xlabel("Voivodeship")
plt.ylabel("Number of Cities")
plt.xticks(rotation=90)  # Rotate x-axis labels for better readability
plt.tight_layout()  # Adjust layout to avoid clipping of labels
plt.show()